# 秒杀功能测试说明

## 📋 功能概述

实现了优惠券秒杀功能，包括：
- ✅ 全局唯一ID生成器
- ✅ 秒杀时间判断
- ✅ 库存扣减（乐观锁防止超卖）
- ✅ 一人一单校验
- ✅ 事务保证数据一致性

## 🔧 准备工作

### 1. 数据库准备

确保已经导入SQL文件，表结构如下：

```sql
-- 秒杀券表
CREATE TABLE tb_seckill_voucher (
    voucher_id BIGINT PRIMARY KEY,
    stock INT NOT NULL,
    create_time DATETIME,
    begin_time DATETIME,
    end_time DATETIME,
    update_time DATETIME
);

-- 优惠券订单表
CREATE TABLE tb_voucher_order (
    id BIGINT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    voucher_id BIGINT NOT NULL,
    pay_type TINYINT,
    status TINYINT,
    create_time DATETIME,
    pay_time DATETIME,
    use_time DATETIME,
    refund_time DATETIME,
    update_time DATETIME
);
```

### 2. 插入测试数据

```sql
-- 插入一个秒杀券（ID=1，库存100，当前时间可以秒杀）
INSERT INTO tb_seckill_voucher (voucher_id, stock, begin_time, end_time, create_time, update_time)
VALUES (
    1, 
    100, 
    NOW(), 
    DATE_ADD(NOW(), INTERVAL 1 HOUR),  -- 1小时后结束
    NOW(), 
    NOW()
);
```

### 3. 启动Redis

```bash
redis-server
```

### 4. 启动应用

```bash
mvn spring-boot:run
```

---

## 🧪 测试用例

### 测试1：正常秒杀

**请求：**
```bash
POST http://localhost:8081/voucher-order/seckill/1
Headers:
  authorization: {你的token}
```

**预期结果：**
```json
{
  "success": true,
  "data": 1729508419584000000  // 订单ID
}
```

**验证：**
```sql
-- 查看库存是否扣减
SELECT stock FROM tb_seckill_voucher WHERE voucher_id = 1;  -- 应该变成99

-- 查看订单是否创建
SELECT * FROM tb_voucher_order WHERE voucher_id = 1;
```

---

### 测试2：重复购买（一人一单）

**请求：** 同一个用户再次请求秒杀接口

**预期结果：**
```json
{
  "success": false,
  "errorMsg": "每人限购一张！"
}
```

---

### 测试3：库存不足

**准备：** 将库存改为0
```sql
UPDATE tb_seckill_voucher SET stock = 0 WHERE voucher_id = 1;
```

**请求：** 再次秒杀

**预期结果：**
```json
{
  "success": false,
  "errorMsg": "库存不足！"
}
```

---

### 测试4：秒杀未开始

**准备：** 将开始时间设置为未来
```sql
UPDATE tb_seckill_voucher 
SET begin_time = DATE_ADD(NOW(), INTERVAL 1 HOUR) 
WHERE voucher_id = 1;
```

**预期结果：**
```json
{
  "success": false,
  "errorMsg": "秒杀尚未开始！"
}
```

---

### 测试5：秒杀已结束

**准备：** 将结束时间设置为过去
```sql
UPDATE tb_seckill_voucher 
SET end_time = DATE_SUB(NOW(), INTERVAL 1 HOUR) 
WHERE voucher_id = 1;
```

**预期结果：**
```json
{
  "success": false,
  "errorMsg": "秒杀已经结束！"
}
```

---

## 🚀 并发测试（JMeter）

### 测试场景：100人同时抢购10张券

**准备数据：**
```sql
UPDATE tb_seckill_voucher SET stock = 10 WHERE voucher_id = 1;
DELETE FROM tb_voucher_order WHERE voucher_id = 1;
```

**JMeter配置：**
```
线程组：
- 线程数：100
- Ramp-Up: 0（立即启动）
- 循环次数：1

HTTP请求：
- 方法：POST
- 路径：/voucher-order/seckill/1
- Headers：authorization: {token}
```

**预期结果：**
- ✅ 成功创建10个订单
- ✅ 90个请求失败（库存不足或已购买）
- ✅ 最终库存为0
- ✅ 无超卖（订单数 = 10）

**验证SQL：**
```sql
-- 查看订单数（应该是10）
SELECT COUNT(*) FROM tb_voucher_order WHERE voucher_id = 1;

-- 查看库存（应该是0）
SELECT stock FROM tb_seckill_voucher WHERE voucher_id = 1;
```

---

## 🔍 核心代码说明

### 1. 全局唯一ID生成器

**位置：** `RedisIdWorker.java`

**原理：**
```
ID = 时间戳(31位) + 序列号(32位)
```

**测试：**
```java
@Test
void testIdWorker() throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(300);
    Runnable task = () -> {
        for (int i = 0; i < 100; i++) {
            long id = redisIdWorker.nextId("order");
            System.out.println("id = " + id);
        }
        latch.countDown();
    };
    
    long begin = System.currentTimeMillis();
    for (int i = 0; i < 300; i++) {
        new Thread(task).start();
    }
    latch.await();
    long end = System.currentTimeMillis();
    
    System.out.println("time = " + (end - begin));
}
```

---

### 2. 乐观锁防止超卖

**SQL：**
```sql
UPDATE tb_seckill_voucher 
SET stock = stock - 1 
WHERE voucher_id = ? AND stock > 0
```

**关键点：**
- `stock > 0` 是乐观锁的核心
- 只有库存大于0时才会更新成功
- 数据库保证原子性

---

### 3. synchronized锁保证一人一单

**代码：**
```java
synchronized (userId.toString().intern()) {
    // 查询 + 创建订单
}
```

**为什么用 intern()？**
- `userId.toString()` 每次都是新对象
- `intern()` 返回字符串常量池中的对象
- 相同的用户ID使用同一把锁

---

### 4. Spring事务代理

**问题：** 直接调用 `this.createVoucherOrder()` 事务不生效

**原因：** Spring事务是基于AOP代理实现的，`this` 是当前对象，不是代理对象

**解决：**
```java
// 获取代理对象
IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
// 通过代理对象调用，事务生效
return proxy.createVoucherOrder(voucherId);
```

**配置：**
```java
@EnableAspectJAutoProxy(exposeProxy = true)  // 暴露代理对象
```

---

## ⚠️ 已知限制

### 1. synchronized只能在单机环境下保证一人一单

**问题：** 集群环境下，不同JVM的锁不互斥

**解决方案：** 使用分布式锁（Redis/Redisson）

### 2. 乐观锁可能导致失败率较高

**场景：** 库存充足，但因为并发冲突导致更新失败

**改进方案：**
```sql
-- 改进：只要库存大于等于要扣减的数量就可以
WHERE voucher_id = ? AND stock >= ?
```

---

## 📈 性能优化建议（下一阶段）

### 1. 使用Redis预判

```java
// 秒杀开始前，将库存加载到Redis
stringRedisTemplate.opsForValue().set("seckill:stock:" + voucherId, stock);

// 秒杀时先在Redis判断
Long stock = stringRedisTemplate.opsForValue().get("seckill:stock:" + voucherId);
if(stock <= 0) {
    return Result.fail("库存不足");
}
```

### 2. 异步下单

```java
// Redis判断通过后，发送消息到队列
rabbitTemplate.convertAndSend("seckill.order", order);

// 异步消费者处理订单入库
@RabbitListener(queues = "seckill.order")
public void handleOrder(VoucherOrder order) {
    // 入库操作
}
```

### 3. 使用Lua脚本

```lua
-- 原子性判断库存 + 扣减 + 记录用户
if(redis.call('get', KEYS[1]) > 0) then
    redis.call('incrby', KEYS[1], -1)
    redis.call('sadd', KEYS[2], ARGV[1])
    return 0
else
    return 1
end
```

---

## 📚 学习要点

1. ✅ **全局唯一ID生成** - 雪花算法思想
2. ✅ **乐观锁** - CAS机制防止超卖
3. ✅ **synchronized** - JVM锁保证一人一单
4. ✅ **Spring事务** - 代理模式原理
5. ✅ **并发测试** - JMeter压测

---

恭喜！🎉 你已经完成了秒杀功能的基础版本实现！

